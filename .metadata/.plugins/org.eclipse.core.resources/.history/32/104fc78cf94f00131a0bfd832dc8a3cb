package jtj_holdem.game.utility;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import jtj_holdem.game.data_structures.PokerHand;
import jtj_holdem.game.enums.ECardNumber;
import jtj_holdem.game.enums.ECardSuit;
import jtj_holdem.game.enums.EPokerHand;
import jtj_holdem.game.interfaces.ICard;

public class PokerHandUtility {

	public static EPokerHand determineBestHand(List<ICard> pHand){

		return null;
	}

	public static PokerHand determineFlush(List<ICard> pHand){

		PokerHand hand = PokerHand.INVALID;

		Map<ECardSuit, List<ICard>> suits = new HashMap<ECardSuit, List<ICard>>();
		for (ECardSuit suit : ECardSuit.values()){
			suits.put(suit, new ArrayList<ICard>());
		}

		for (ICard card : pHand){
			suits.get(card.getSuit()).add(card);
		}

		for (ECardSuit suit : suits.keySet()){
			if (suits.get(suit).size() >= 5){
				hand = new PokerHand(EPokerHand.FLUSH, suits.get(suit), Collections.<ICard> emptyList());
			}
		}
		return hand;
	}

	public static PokerHand determineStraight(List<ICard> pHand){

		PokerHand hand = PokerHand.INVALID;

		List<ICard> sortedList = new ArrayList<>(pHand);
		Collections.sort(sortedList);

		List<ICard> consecutiveCards = new ArrayList<ICard>();
		int lastNumber = 0;
		for (ICard card : sortedList){
			if (lastNumber > 0){
				if (card.getNumber().getNumber() == lastNumber + 1){
					consecutiveCards.add(card);
				}else if (card.getNumber().getNumber() != lastNumber){
					consecutiveCards.clear();
				}
				if (consecutiveCards.size() == 5){
					hand = new PokerHand(EPokerHand.STRAIGHT, consecutiveCards, Collections.<ICard> emptyList());
					break;
				}
			}else{
				//This is the very first card so just add it to our consecutive list
				//as we have nothing to compare it to yet.
				consecutiveCards.add(card);
				if (card.getNumber() == ECardNumber.TWO){
					//since two is our first we need to check for an ace and add it if its there.
					if (sortedList.get(sortedList.size() - 1).getNumber() == ECardNumber.ACE){
						consecutiveCards.add(sortedList.get(sortedList.size() - 1));
					}
				}
			}
			lastNumber = card.getNumber().getNumber();
		}

		return hand;
	}

	public static PokerHand determineFourOfAKind(final List<ICard> pHand){

		PokerHand hand = PokerHand.INVALID;
		Map<ECardNumber, List<ICard>> numbers = organizeByNumber(pHand);

		for (ECardNumber number : numbers.keySet()){
			if (numbers.get(number).size() == 4){
				List <ICard> kickers = new ArrayList<ICard>(pHand);
				kickers.removeAll(numbers.get(number));
				hand = new PokerHand(EPokerHand.FOUR_OF_A_KIND, numbers.get(number), kickers);
				break;
			}
		}

		return hand;
	}

	public static PokerHand determineThreeOfAKind(final List<ICard> pHand){

		PokerHand hand = PokerHand.INVALID;
		Map<ECardNumber, List<ICard>> numbers = organizeByNumber(pHand);

		for (ECardNumber number : numbers.keySet()){
			if (numbers.get(number).size() == 3){
				List <ICard> kickers = new ArrayList<ICard>(pHand);
				kickers.removeAll(numbers.get(number));
				hand = new PokerHand(EPokerHand.THREE_OF_A_KIND, numbers.get(number), kickers);
				break;
			}
		}

		return hand;
	}
	
	public static PokerHand determineTwoPair(final List<ICard> pHand){

		PokerHand hand = PokerHand.INVALID;
		Map<ECardNumber, List<ICard>> numbers = organizeByNumber(pHand);

		List <ICard> pair1 = Collections.emptyList();
		List <ICard> pair2 = Collections.emptyList();
		for (ECardNumber number : numbers.keySet()){
			if (numbers.get(number).size() == 2){
				if (pair1.isEmpty()){
					pair1 = numbers.get(number);
				}else if (!pair1.isEmpty() && pair2.isEmpty()){
					pair2 = numbers.get(number);
				}
			}
		}
		if (!pair1.isEmpty() && !pair2.isEmpty()){
			List <ICard> pairs = new ArrayList<ICard>(pair1);
			pairs.addAll(pair2);
			List <ICard> kickers = new ArrayList<ICard>(pHand);
			kickers.removeAll(numbers.get(pairs));
			hand = new PokerHand(EPokerHand.TWO_PAIR, pairs, kickers);
		}

		return hand;
	}
	
	public static PokerHand determineOnePair(final List <ICard> pHand){
		PokerHand hand = PokerHand.INVALID;
		Map<ECardNumber, List<ICard>> numbers = organizeByNumber(pHand);
		
		return hand;
	}
	
	private static Map<ECardNumber, List<ICard>> organizeByNumber(final List<ICard> pHand){

		Map<ECardNumber, List<ICard>> numbers = new HashMap<ECardNumber, List<ICard>>();
		for (ECardNumber number : ECardNumber.values()){
			numbers.put(number, new ArrayList<ICard>());
		}
		for (ICard card : pHand){
			numbers.get(card.getNumber()).add(card);
		}
		return numbers;
	}
}
