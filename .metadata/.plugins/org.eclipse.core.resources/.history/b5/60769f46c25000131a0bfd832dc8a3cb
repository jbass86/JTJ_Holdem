package jtj_holdem.game.data_structures;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import jtj_holdem.game.enums.ECardNumber;
import jtj_holdem.game.enums.EPokerHand;
import jtj_holdem.game.interfaces.ICard;

public class PokerHand implements Comparable<PokerHand>{

	public static final PokerHand INVALID = new PokerHand(EPokerHand.NO_HAND, Collections.<ICard> emptyList(),
			Collections.<ICard> emptyList());

	private final EPokerHand mHand;

	private final List<ICard> mCards;

	private final List<ICard> mKickers;

	public PokerHand(final EPokerHand pHand, final List<ICard> pCards, final List<ICard> pKickers){
		mHand = pHand;
		mCards = pCards;
		mKickers = pKickers;
	}

	public EPokerHand getHand() {
		return mHand;
	}

	public List<ICard> getCards() {
		return mCards;
	}

	public List<ICard> getKickers() {
		return mKickers;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((mCards == null) ? 0 : mCards.hashCode());
		result = prime * result + ((mHand == null) ? 0 : mHand.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PokerHand other = (PokerHand) obj;
		if (mCards == null) {
			if (other.mCards != null)
				return false;
		} else if (!mCards.equals(other.mCards))
			return false;
		if (mHand != other.mHand)
			return false;
		return true;
	}

	public boolean isValid(){
		return !this.equals(INVALID);
	}

	@Override
	public int compareTo(PokerHand pO) {

		if (getHand().compareTo(pO.getHand()) == 0){
			//both hands are the same so we have to get more technical.

			switch(mHand){
			case STRAIGHT_FLUSH:
				//straight flush should just follow the same rules as a straight
				return compareStraight(pO);
			case FOUR_OF_A_KIND:
				break;
			case FULL_HOUSE:
				break;
			case FLUSH:
				break;
			case STRAIGHT:
				return compareStraight(pO);
			case THREE_OF_A_KIND:
				break;
			case TWO_PAIR:
				break;
			case ONE_PAIR:
				break;
			case HIGH_CARD:
				break;
			default:
				return 0;
			}

		}
		return getHand().compareTo(pO.getHand());	
	}
	
	private int compareStraight(final PokerHand pO){
		
		List<ICard> hand1 = new ArrayList<ICard>(getCards());
		List<ICard> hand2 = new ArrayList<ICard>(pO.getCards());
		Collections.sort(hand1);
		Collections.sort(hand2);
		
		//if either hand is an ace low straight the sorting will actually put ace at the top of the list which would
		//set it way higher then it should be so it needs to be removed
		if (hand1.get(0).getNumber() == ECardNumber.TWO && hand1.get(hand1.size() - 1).getNumber() == ECardNumber.ACE){
			hand1.remove(hand1.size() - 1);
		}
		if (hand2.get(0).getNumber() == ECardNumber.TWO && hand2.get(hand2.size() - 1).getNumber() == ECardNumber.ACE){
			hand2.remove(hand2.size() - 1);
		}
		
		//compare the highest card in the stright of each hand
		return hand1.get(hand1.size() - 1).getNumber().compareTo(hand2.get(hand1.size() - 2).getNumber());
	}
}
